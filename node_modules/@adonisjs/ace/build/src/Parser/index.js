"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const getopts_1 = __importDefault(require("getopts"));
const MissingCommandArgument_1 = require("../Exceptions/MissingCommandArgument");
const InvalidFlagType_1 = require("../Exceptions/InvalidFlagType");
class Parser {
    constructor(_registeredFlags) {
        this._registeredFlags = _registeredFlags;
    }
    _preProcessFlag(flag, options) {
        if (flag.alias) {
            options.alias[flag.alias] = flag.name;
        }
        if (flag.type === 'boolean') {
            options.boolean.push(flag.name);
        }
        if (['string', 'array'].indexOf(flag.type) > -1) {
            options.string.push(flag.name);
        }
        if (flag.default !== undefined) {
            options.default[flag.name] = flag.default;
        }
    }
    castFlag(flag, parsed) {
        const value = parsed[flag.name];
        if (['boolean', 'string', 'number'].indexOf(flag.type) > -1) {
            return;
        }
        if (Array.isArray(value)) {
            return;
        }
        if (flag.type === 'array') {
            parsed[flag.name] = value ? value.split(',') : [];
            return;
        }
        if (flag.type === 'numArray') {
            parsed[flag.name] = value ? (typeof (value) === 'string'
                ? value.split(',').map((one) => Number(one))
                : [Number(value)]) : [];
        }
    }
    validateFlag(flag, parsed, command) {
        const value = parsed[flag.name];
        if (value === undefined) {
            return;
        }
        if (flag.type === 'string' && typeof (value) !== 'string') {
            throw InvalidFlagType_1.InvalidFlagType.invoke(flag.name, flag.type, command);
        }
        if (flag.type === 'number' && typeof (value) !== 'number') {
            throw InvalidFlagType_1.InvalidFlagType.invoke(flag.name, flag.type, command);
        }
        if (flag.type === 'numArray' && value.findIndex((one) => {
            return typeof (one) !== 'number' || isNaN(one);
        }) > -1) {
            throw InvalidFlagType_1.InvalidFlagType.invoke(flag.name, flag.type, command);
        }
    }
    validateArg(arg, index, parsed, command) {
        const value = parsed._[index];
        if (value === undefined && arg.required) {
            throw MissingCommandArgument_1.MissingCommandArgument.invoke(arg.name, command);
        }
    }
    parse(argv, command) {
        let options = { alias: {}, boolean: [], default: {}, string: [] };
        const globalFlags = Object.keys(this._registeredFlags).map((name) => this._registeredFlags[name]);
        globalFlags.forEach((flag) => this._preProcessFlag(flag, options));
        if (command) {
            command.flags.forEach((flag) => this._preProcessFlag(flag, options));
        }
        const parsed = getopts_1.default(argv, options);
        globalFlags.forEach((flag) => {
            this.castFlag(flag, parsed);
            this.validateFlag(flag, parsed);
        });
        if (command) {
            command.flags.forEach((flag) => {
                this.castFlag(flag, parsed);
                this.validateFlag(flag, parsed, command);
            });
        }
        return parsed;
    }
}
exports.Parser = Parser;
