"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Hooks_1 = require("../Hooks");
const Parser_1 = require("../Parser");
const validateCommand_1 = require("../utils/validateCommand");
const help_1 = require("../utils/help");
class Kernel {
    constructor() {
        this.commands = {};
        this.flags = {};
        this._hooks = new Hooks_1.Hooks();
    }
    _executeGlobalFlagsHandlers(options, command) {
        const globalFlags = Object.keys(this.flags);
        globalFlags.forEach((name) => {
            const value = options[name];
            if (value === undefined) {
                return;
            }
            if ((typeof (value) === 'string' || Array.isArray(value)) && !value.length) {
                return;
            }
            this.flags[name].handler(options[name], options, command);
        });
    }
    before(action, callback) {
        this._hooks.add('before', action, callback);
        return this;
    }
    after(action, callback) {
        this._hooks.add('after', action, callback);
        return this;
    }
    register(commands) {
        commands.forEach((command) => {
            command.boot();
            validateCommand_1.validateCommand(command);
            this.commands[command.commandName] = command;
        });
        return this;
    }
    getSuggestions(name, distance = 3) {
        const levenshtein = require('fast-levenshtein');
        const commands = this.manifestCommands ? this.manifestCommands : this.commands;
        return Object.keys(commands).filter((commandName) => {
            return levenshtein.get(name, commandName) <= distance;
        });
    }
    flag(name, handler, options) {
        this.flags[name] = Object.assign({
            name,
            propertyName: name,
            handler,
            type: 'boolean',
        }, options);
        return this;
    }
    async find(argv) {
        if (this.manifestCommands && this.manifestCommands[argv[0]]) {
            await this._hooks.excute('before', 'find', this.manifestCommands[argv[0]]);
            const command = this._manifest.loadCommand(this.manifestCommands[argv[0]].commandPath);
            await this._hooks.excute('after', 'find', command);
            return command;
        }
        const command = this.commands[argv[0]] || null;
        await this._hooks.excute('before', 'find', command);
        await this._hooks.excute('after', 'find', command);
        return command;
    }
    async runCommand(argv, commandInstance) {
        argv = argv.splice(1);
        const parser = new Parser_1.Parser(this.flags);
        const command = commandInstance.constructor;
        const parsedOptions = parser.parse(argv, command);
        this._executeGlobalFlagsHandlers(parsedOptions, command);
        command.args.forEach((arg, index) => {
            parser.validateArg(arg, index, parsedOptions, command);
        });
        commandInstance.parsed = parsedOptions;
        for (let i = 0; i < command.args.length; i++) {
            const arg = command.args[i];
            if (arg.type === 'spread') {
                commandInstance[arg.propertyName] = parsedOptions._.slice(i);
                break;
            }
            else {
                commandInstance[arg.propertyName] = parsedOptions._[i];
            }
        }
        command.flags.forEach((flag) => {
            commandInstance[flag.propertyName] = parsedOptions[flag.name];
        });
        await this._hooks.excute('before', 'run', commandInstance);
        const response = await this._container
            ? this._container.call(commandInstance, 'handle', [])
            : commandInstance.handle();
        await this._hooks.excute('after', 'run', commandInstance);
        return response;
    }
    async handle(argv) {
        if (!argv.length) {
            return;
        }
        if (this._manifest) {
            this.manifestCommands = await this._manifest.load();
        }
        const hasMentionedCommand = !argv[0].startsWith('-');
        if (!hasMentionedCommand) {
            const parsedOptions = new Parser_1.Parser(this.flags).parse(argv);
            this._executeGlobalFlagsHandlers(parsedOptions);
            return;
        }
        let command = await this.find(argv);
        if (!command) {
            throw new Error(`${argv[0]} is not a registered command`);
        }
        const commandInstance = this._container
            ? this._container.make(command, [false])
            : new command(false);
        return this.runCommand(argv, commandInstance);
    }
    useManifest(manifest) {
        this._manifest = manifest;
        return this;
    }
    useContainer(container) {
        this._container = container;
        return this;
    }
    printHelp(command) {
        if (command) {
            help_1.printHelpFor(command);
        }
        else {
            let commands;
            if (this.manifestCommands) {
                commands = Object.keys(this.manifestCommands).map((name) => this.manifestCommands[name]);
            }
            else {
                commands = Object.keys(this.commands).map((name) => this.commands[name]);
            }
            const flags = Object.keys(this.flags).map((name) => this.flags[name]);
            help_1.printHelp(commands, flags);
        }
    }
}
exports.Kernel = Kernel;
