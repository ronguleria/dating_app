"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const figures_1 = __importDefault(require("figures"));
const util_1 = require("util");
const string_width_1 = __importDefault(require("string-width"));
const colors_1 = require("@poppinss/colors");
class Logger {
    constructor(_baseOptions) {
        this._baseOptions = _baseOptions;
        this.actions = {
            success: {
                color: 'green',
                badge: figures_1.default.tick,
                logLevel: 'info',
            },
            fatal: {
                color: 'red',
                badge: figures_1.default.cross,
                logLevel: 'error',
            },
            error: {
                color: 'red',
                badge: figures_1.default.cross,
                logLevel: 'error',
            },
            info: {
                color: 'blue',
                badge: figures_1.default.info,
                logLevel: 'info',
            },
            complete: {
                color: 'cyan',
                badge: figures_1.default.checkboxOn,
                logLevel: 'info',
            },
            pending: {
                color: 'magenta',
                badge: figures_1.default.checkboxOff,
                logLevel: 'info',
            },
            create: {
                color: 'green',
                badge: figures_1.default.tick,
                logLevel: 'info',
            },
            update: {
                color: 'yellow',
                badge: figures_1.default.tick,
                logLevel: 'info',
            },
            delete: {
                color: 'blue',
                badge: figures_1.default.tick,
                logLevel: 'info',
            },
            watch: {
                color: 'yellow',
                badge: figures_1.default.ellipsis,
                logLevel: 'info',
            },
            start: {
                color: 'green',
                badge: figures_1.default.play,
                logLevel: 'info',
            },
            stop: {
                color: 'magenta',
                badge: figures_1.default.squareSmallFilled,
                logLevel: 'info',
            },
            compile: {
                color: 'yellow',
                badge: figures_1.default.pointer,
                logLevel: 'info',
            },
            skip: {
                color: 'magenta',
                badge: figures_1.default.bullet,
                logLevel: 'info',
            },
        };
        this.logs = [];
        this._configure();
        this._computeBiggestLabel();
    }
    _configure() {
        this._baseOptions = Object.assign({
            color: true,
            icon: true,
            underline: true,
            fake: false,
        }, this._baseOptions);
        this._colors = this._baseOptions.fake ? new colors_1.FakeColors() : new colors_1.Colors();
    }
    _computeBiggestLabel() {
        this._biggestLabel = Math.max(...Object.keys(this.actions).map((name) => {
            const action = this.actions[name];
            const badge = this._colors[action.color](action.badge);
            const label = this._colors[action.color]().underline(name);
            return string_width_1.default(`${badge}  ${label}`);
        }));
    }
    _normalizeMessage(message) {
        if (message['stack']) {
            message['icon'] = this._baseOptions.icon;
            message['color'] = this._baseOptions.color;
            message['underline'] = this._baseOptions.underline;
            return message;
        }
        if (typeof (message) === 'string') {
            return Object.assign({}, this._baseOptions, { message });
        }
        if (message.message['stack']) {
            const options = Object.assign({}, this._baseOptions, message);
            message.message['icon'] = options.icon;
            message.message['color'] = options.color;
            message.message['underline'] = options.underline;
            return message.message;
        }
        return Object.assign({}, this._baseOptions, message);
    }
    _getWhitespace(length) {
        return this._baseOptions.fake ? ' ' : new Array(length + 1).join(' ');
    }
    _getIcon(name, messageNode) {
        const action = this.actions[name];
        if (this._baseOptions.fake) {
            return '';
        }
        if (!messageNode.icon) {
            return this._getWhitespace(3);
        }
        if (!messageNode.color) {
            return `${action.badge}${this._getWhitespace(2)}`;
        }
        return `${this._colors[action.color](action.badge)}${this._getWhitespace(2)}`;
    }
    _getLabel(name, messageNode) {
        const action = this.actions[name];
        if (messageNode.color && messageNode.underline) {
            return this._colors.underline()[action.color](name);
        }
        if (messageNode.color) {
            return this._colors[action.color](name);
        }
        return name;
    }
    _getPrefix(messageNode) {
        if (messageNode.prefix) {
            return `${this._colors.dim(messageNode.prefix)}${this._getWhitespace(1)}`;
        }
        return '';
    }
    _getSuffix(messageNode) {
        if (messageNode.suffix) {
            return `${this._getWhitespace(1)}${this._colors.dim().yellow(messageNode.suffix)}`;
        }
        return '';
    }
    _formatStack(name, message) {
        if (name !== 'fatal' || !message['stack']) {
            return message.message;
        }
        const stack = message['stack'].split('\n');
        return `${stack.shift()}\n${stack.map((line) => {
            return `${this._colors.dim(line)}`;
        }).join('\n')}`;
    }
    log(name, messageNode, ...args) {
        const normalizedMessage = this._normalizeMessage(messageNode);
        const prefix = this._getPrefix(normalizedMessage);
        const icon = this._getIcon(name, normalizedMessage);
        const label = this._getLabel(name, normalizedMessage);
        const message = this._formatStack(name, normalizedMessage);
        const suffix = this._getSuffix(normalizedMessage);
        if (this._baseOptions.fake) {
            const log = util_1.format(`${prefix}${icon}${label} ${message}${suffix}`, ...args);
            this.logs.push(log);
            return log;
        }
        const method = this.actions[name].logLevel === 'error' ? 'error' : 'log';
        const justifyWhitespace = this._getWhitespace((this._biggestLabel - string_width_1.default(`${icon}${label}`)) + 2);
        console[method](`${prefix}${icon}${label}${justifyWhitespace}${message}${suffix}`, ...args);
    }
    success(message, ...args) {
        return this.log('success', message, ...args);
    }
    error(message, ...args) {
        return this.log('error', message, ...args);
    }
    fatal(message, ...args) {
        return this.log('fatal', message, ...args);
    }
    info(message, ...args) {
        return this.log('info', message, ...args);
    }
    complete(message, ...args) {
        return this.log('complete', message, ...args);
    }
    pending(message, ...args) {
        return this.log('pending', message, ...args);
    }
    create(message, ...args) {
        return this.log('create', message, ...args);
    }
    update(message, ...args) {
        return this.log('update', message, ...args);
    }
    delete(message, ...args) {
        return this.log('delete', message, ...args);
    }
    watch(message, ...args) {
        return this.log('watch', message, ...args);
    }
    start(message, ...args) {
        return this.log('start', message, ...args);
    }
    stop(message, ...args) {
        return this.log('stop', message, ...args);
    }
    compile(message, ...args) {
        return this.log('compile', message, ...args);
    }
    skip(message, ...args) {
        return this.log('skip', message, ...args);
    }
}
exports.Logger = Logger;
